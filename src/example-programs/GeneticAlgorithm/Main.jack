class Main {
    static int initialX;
    static int initialY;
    static int goalX;
    static int goalY;
    static boolean onlyBest;
    static boolean isAdjacent;
    static Array obstacles;
    static Array floodQueue;
    static int floodQueueLength;
    static int floodDist;
    static boolean initialGoalDist;
    static boolean initialBestDotFitness;

    static String generationString;
    static String goalStepCountString;
    static String goalDistanceString;
    static String NAString;
    static String placeString;
    static String escString;
    static String precomputingString;

    function void init() {
        var int i;
        let generationString = "Generation: ";
        let goalStepCountString = "Goal step count: ";
        let goalDistanceString = "Goal distance: ";
        let NAString = "NA";
        let placeString = "Place obstacles with the arrow, enter, and delete keys.";
        let escString = "Press esc to finish.";
        let precomputingString = "Precomputing fitnesses...";
        let floodQueue = Array.new(100);
        let obstacles = Array.new(512);
        while (i < 512) {
            let obstacles[i] = false;
            let i = i + 1;
        }
    }

    function void main() {
        var int brainSize;
        var int populationCount;
        var boolean firstPairComponent;
        do Util.init();
        do AccelerationVectorPair.init();
        do Population.init();
        do Main.init();

        // do Screen.drawRectangle(80, 67, 432, 144);
        do Screen.drawRectangle(70, 57, 442, 154);
        do Screen.setColor(false);
        // do Screen.drawRectangle(82, 69, 430, 142);
        do Screen.drawRectangle(72, 59, 440, 152);
        do Output.moveCursor(6, 11);
        do Output.printString("Welcome to my genetic algorithm simulation!");
        do Output.moveCursor(8, 10);
        do Output.printString("The objective is for dots to reach a goal in");
        do Output.moveCursor(9, 17);
        do Output.printString("as little steps as possible.");
        do Output.moveCursor(12, 20);
        do Output.printString("Press any key to start.");
        while (Keyboard.keyPressed() = 0)
            do Util.random();
        do Screen.drawRectangle(70, 57, 442, 154);

        let initialX = 10;
        let initialY = 128;
        let goalX = 500;
        let goalY = 128;
        let onlyBest = false;
        do Main.selectObstacles();
        let brainSize = (initialGoalDist / 2) - 2;
        let populationCount = (8000 / (brainSize + 2)) - 2;
        do Output.printInt(brainSize);
        do Output.printInt(populationCount);
        do Sys.halt();
        do Brain.config(brainSize);
        do Dot.config(initialX, initialY, goalX, goalY, brainSize, obstacles);
        do Population.config(populationCount, brainSize, onlyBest, initialBestDotFitness);
        do Main.refreshDisplay();
        while (true) {
            if (Population.allDotsDead()) {
                do Population.naturalSelection();
                if (Keyboard.keyPressed() = 140) {
                    do Main.selectObstacles();
                }
                do Main.refreshDisplay();
                let firstPairComponent = false;
            } else {
                let firstPairComponent = ~firstPairComponent;
                do Population.update(firstPairComponent);
            }
        }
    }

    function void selectObstacles() {
        var int selectorX;
        var int selectorY;
        var int selectorIndex;
        var int key;
        var boolean drag;
        var boolean draggingEnter;
        var int i, i2;
        var boolean allowUp;
        var boolean allowDown;
        var boolean allowRight;
        var boolean allowLeft;
        while (~(i > 511)) {
            if (~(obstacles[i] = true))
                let obstacles[i] = false;
            let i = i + 1;
        }

        do Output.moveCursor(3, 5);
        do Output.printString(placeString);
        do Output.moveCursor(4, 22);
        do Output.printString(escString);
        let selectorX = 256;
        let selectorY = 112;
        let selectorIndex = 240;
        let key = 1;
        while (~(key = 140)) {
            while (~(key > 0)) {
                let key = Keyboard.keyPressed();
            }

            do Screen.setColor(obstacles[selectorIndex] = true);
            do Screen.drawRectangle(selectorX, selectorY, selectorX + 15, selectorY + 15);
            do Screen.setColor(true);

            if (~(key = 140)) {
                do Main.drawGoal();
                do Screen.drawRectangle(initialX - 1, initialY - 1, initialX + 1, initialY + 1);
                if (key = 130) {
                    if (~(selectorX = 0)) {
                        let selectorX = selectorX - 16;
                        let selectorIndex = selectorIndex - 1;
                    }
                } else if (key = 131) {
                    if (~(selectorY = 0)) {
                        let selectorY = selectorY - 16;
                        let selectorIndex = selectorIndex - 32;
                    }
                } else if (key = 132) {
                    if (~(selectorX = 496)) {
                        let selectorX = selectorX + 16;
                        let selectorIndex = selectorIndex + 1;
                    }
                } else if (key = 133) {
                    if (~(selectorY = 240)) {
                        let selectorY = selectorY + 16;
                        let selectorIndex = selectorIndex + 32;
                    }
                }
                do Screen.drawRectangle(selectorX, selectorY, selectorX + 15, selectorY + 15);
                do Screen.setColor(false);
                do Screen.drawRectangle(selectorX + 1, selectorY + 1, selectorX + 14, selectorY + 14);
                do Screen.setColor(true);
                do Screen.drawRectangle(selectorX + 2, selectorY + 2, selectorX + 13, selectorY + 13);
                if ((key = 128) | (key = 129)) {
                    let drag = ~(drag & (draggingEnter = (key = 128)));
                    let draggingEnter = key = 128;
                    while (~(key = 0)) {
                        let key = Keyboard.keyPressed();
                    }
                }

                if (drag) {
                    let obstacles[selectorIndex] = draggingEnter;
                }

                if (key = 1) {
                    // wait for key release
                    while (~(Keyboard.keyPressed() = 0)) {}
                    // wait for key press then hide
                    while (Keyboard.keyPressed() = 0) {}
                    do Screen.setColor(false);
                    do Screen.drawRectangle(40, 34, 480, 56);
                    do Screen.setColor(true);
                    do Main.drawObstacles();
                    let key = 2;
                } else {
                    let key = 0;
                }
                do Sys.wait(150);
            }
        }
        do Screen.clearScreen();
        do Output.moveCursor(11, 21);
        do Output.printString(precomputingString);

        let i = Main.getGridIndex(goalX, goalY);
        let floodQueue[0] = i;
        let floodQueueLength = 1;
        let obstacles[i] = 1;
        while (floodQueueLength > 0) {
            let i = floodQueue[0];
            let i2 = 1;
            while (~(i2 = floodQueueLength)) {
                let floodQueue[i2 - 1] = floodQueue[i2];
                let i2 = i2 + 1;
            }

            let floodQueueLength = floodQueueLength - 1;
            let floodDist = obstacles[i];
            let allowUp = i > 31;
            let allowDown = i < 480;
            let allowRight = ~((i & 31) = 31);
            let allowLeft = ~((i & 31) = 0);

            let isAdjacent = true;
            if (allowUp) {
                do Main.floodIndex(i, 1, 32);
            }

            if (allowRight) {
                do Main.floodIndex(i, 32, -1);
            }

            if (allowDown) {
                do Main.floodIndex(i, -1, -32);
            }

            if (allowLeft) {
                do Main.floodIndex(i, -32, 1);
            }

            let isAdjacent = false;
            if (allowUp) {
                if (allowRight) {
                    do Main.floodIndex(i - 31, -1, 32);
                }

                if (allowLeft) {
                    do Main.floodIndex(i - 33, 32, 1);
                }
            }

            if (allowDown) {
                if (allowRight) {
                    do Main.floodIndex(i + 33, -32, -1);
                }

                if (allowLeft) {
                    do Main.floodIndex(i + 31, 1, -32);
                }
            }
        }
        let i2 = Main.getGridIndex(initialX, initialY);
        let initialGoalDist = obstacles[i2];
        let i = 0;
        while (i < 512) {
            if (~((obstacles[i] = true) | (obstacles[i] = false))) {
                let obstacles[i] = Math.min(3276, 32767 / obstacles[i]);
                if (i = i2) {
                    let initialBestDotFitness = obstacles[i];
                }
            } else if (i = i2) {
                let initialGoalDist = 200;
                let initialBestDotFitness = 1;
            }
            let i = i + 1;
        }
        do Screen.setColor(false);
        do Screen.drawRectangle(168, 122, 368, 133);
        do Screen.setColor(true);
    }

    function void floodIndex(int i, int leftIndex, int rightIndex) {
        var int floodVal;
        var int penalty;
        var int topLeft;
        var int topRight;
        var int bottomLeft;
        var int bottomRight;

        if (isAdjacent) {
            let bottomLeft = i - leftIndex;
            let bottomRight = i + leftIndex;
            let topLeft = bottomLeft - rightIndex;
            let topRight = bottomRight - rightIndex;

            let penalty = Math.min(
                (Main.floodIndexOutOfBounds(i, bottomLeft) | (obstacles[bottomLeft] = true)) +
                (Main.floodIndexOutOfBounds(i, bottomRight) | (obstacles[bottomRight] = true)),
                (Main.floodIndexOutOfBounds(i, topLeft) | (obstacles[topLeft] = true)) +
                (Main.floodIndexOutOfBounds(i, topRight) | (obstacles[topRight] = true))
            );
            let i = i - rightIndex;
        } else {
            let rightIndex = Main.floodIndexOutOfBounds(i, i + rightIndex) | (obstacles[i + rightIndex] = true);
            let leftIndex = Main.floodIndexOutOfBounds(i, i + leftIndex) | (obstacles[i + leftIndex] = true);
            let penalty = leftIndex + rightIndex;
        }

        if (penalty = -2) {
            if (isAdjacent) {
                let floodVal = floodDist + 12;
            } else {
                let floodVal = floodDist + 65;
            }
        } else if (penalty = -1) {
            if (isAdjacent) {
                // cant be ran because this will override the + 13 case
                let floodVal = floodDist + 9;
            } else {
                return;
            }
        } else {
            if (isAdjacent) {
                let floodVal = floodDist + 5;
            } else {
                let floodVal = floodDist + 7;
            }
        }

        if ((obstacles[i] = false) | (obstacles[i] > floodVal)) {
            let obstacles[i] = floodVal;
            let floodQueue[floodQueueLength] = i;
            let floodQueueLength = floodQueueLength + 1;
        }
    }

    function boolean floodIndexOutOfBounds(int originIndex, int newIndex) {
        return (newIndex < 0) | (newIndex > 511) |
                (((originIndex & 31) = 31) & ((newIndex & 31) = 0)) |
                (((originIndex & 31) = 0) & ((newIndex & 31) = 31));
    }

    function void drawGoal() {
        do Screen.drawRectangle(goalX - 2, goalY - 2, goalX + 2, goalY + 2);
    }

    function void drawObstacles() {
        var int i;
        var int obstacleY;
        var int obstacleX;
        while (i < 512) {
            let obstacleY = 0;
            let obstacleX = i;
            while (~(obstacleX < 32)) {
                let obstacleX = obstacleX - 32;
                let obstacleY = obstacleY + 16;
            }
            let obstacleX = i - (obstacleY + obstacleY);
            let obstacleX = obstacleX + obstacleX;
            let obstacleX = obstacleX + obstacleX;
            let obstacleX = obstacleX + obstacleX;
            let obstacleX = obstacleX + obstacleX;
            if (obstacles[i] = true)
                do Screen.drawRectangle(obstacleX, obstacleY, obstacleX + 15, obstacleY + 15);
            let i = i + 1;
        }
    }

    function void refreshDisplay() {
        var int bestDotFitness;
        var int minStep;
        do Main.drawGoal();
        do Main.drawObstacles();
        do Output.moveCursor(21, 0);
        do Output.printString(generationString);
        do Output.printInt(Population.getGen());
        do Output.println();
        let minStep = Dot.getMinStep();
        if (minStep = 32767) {
            do Output.printString(goalDistanceString);
            let bestDotFitness = Population.getBestDotFitness();
            if ((bestDotFitness = true) | (bestDotFitness = 1)) {
                do Output.printInt(NAString);
            } else {
                do Output.printInt(32767 / bestDotFitness);
            }
        } else {
            do Output.printString(goalStepCountString);
            do Output.printInt(minStep);
        }
    }

    function int getGridIndex(int posX, int posY) {
        var int ret;
        while (~(posY < 16)) {
            let posY = posY - 16;
            let ret = ret + 32;
        }
        // ret should be (posY / 16) * 32

        while (~(posX < 16)) {
            let posX = posX - 16;
            let ret = ret + 1;
        }
        // ret should be (posY / 16) * 32 + (posX / 16)
        return ret;
    }
}