class Dot {
    static int initialX, initialY;
    field int posX, posY;
    field int velX, velY;
    field AccelerationVector acc;
    static int goalX, goalY;
    field int prevX, prevY;
    field Brain brain;
    field boolean dead;
    field boolean reachedGoal;
    static int stepWeight;
    static int brainSize;
    static int minStep;
    static Array obstacles;

    function void config(int _initialX, int _initialY, int _goalX, int _goalY, int _brainSize, Array _obstacles) {
        let initialX = _initialX;
        let initialY = _initialY;
        let goalX = _goalX;
        let goalY = _goalY;
        let brainSize = _brainSize;
        let minStep = 32767;
        let stepWeight = (32767 - 10000) / _brainSize;
        let obstacles = _obstacles;
    }

    constructor Dot new() {
        let brain = Brain.new();
        do instantiate();
        return this;
    }

    method void instantiate() {
        let dead = false;
        let reachedGoal = false;
        let prevX = initialX - 1;
        let prevY = initialY - 1;

        let posX = initialX;
        let posY = initialY;
        let velX = 0;
        let velY = 0;
        let acc = null;
    }

    method boolean getDead() {
        return dead;
    }

    function int getMinStep() {
        return minStep;
    }

    function void setMinStep(int _minStep) {
        let minStep = _minStep;
    }

    method Brain getBrain() {
        return brain;
    }

    method void setBrain(Brain _brain) {
        let brain = _brain;
    }

    method boolean getReachedGoal() {
        return reachedGoal;
    }

    method void update(boolean andShow) {
        var boolean newVelXIsNegative, newVelYIsNegative;
        if (~(brain.getStep() > minStep)) {
            if (~dead) {
                if (~(brainSize > brain.getStep())) {
                    let dead = true;
                } else {
                    let acc = brain.getNextDirection();
                }

                let velX = velX + acc.getX();
                let velY = velY + acc.getY();
                let newVelXIsNegative = velX < 0;
                let newVelYIsNegative = velY < 0;

                if (newVelXIsNegative) {
                    let velX = -velX;
                }

                if (newVelYIsNegative) {
                    let velY = -velY;
                }

                if (~(velX > 5)) {
                    if (~(velX = 4)) {
                        if (~(velX = 0)) {
                            if (~(velY < 5)) {
                                let velY = 4;
                            }
                        } else if (~(velY < 6)) {
                            let velY = 5;
                        }
                    } else if (~(velY < 4)) {
                        let velY = 3;
                    }
                } else {
                    let velX = 5;
                    let velY = 0;
                }

                if (newVelXIsNegative) {
                    let velX = -velX;
                }

                if (newVelYIsNegative) {
                    let velY = -velY;
                }

                let posX = posX + velX;
                let posY = posY + velY;

                if (~((posX < 2) | (posY < 2) | (posX > 510) | (posY > 254) | (obstacles[Main.getGridIndex(posX, posY)] = true))) {
                    if (~((Math.abs(posX - goalX) > 3) | (Math.abs(posY - goalY) > 3))) {
                        let reachedGoal = true;
                        let dead = true;
                    }
                } else {
                    let dead = true;
                }
            }
        } else {
            let dead = true;
        }

        if (~andShow) {
            let prevX = posX - 1;
            let prevY = posY - 1;
        } else if (~dead) {
            do Screen.setColor(false);
            do Screen.drawRectangle(prevX, prevY, prevX + 2, prevY + 2);
            do Screen.setColor(true);
            let prevX = posX - 1;
            let prevY = posY - 1;
            do Screen.drawRectangle(prevX, prevY, prevX + 2, prevY + 2);
        }
    }

    method int calculateFitness() {
        if (~reachedGoal) {
            // needed if goal is blocked off completely and the current grid index hasnt been flooded (is 0)
            // for example if this was 0 then during the natural selection process no dot would be selected
            // because everything is 0 and it would all just evolve off of one random dot which makes no sense
            // it's also not easily possible to set it to 1 in flood itself because of ROM concerns
            return Math.max(1, obstacles[Main.getGridIndex(prevX + 1, prevY + 1)]);
        }
        return Math.max(10000, 32767 - (stepWeight * brain.getStep()));
    }

    method void dispose() {
        do brain.dispose();
        do Memory.deAlloc(this);
    }
}